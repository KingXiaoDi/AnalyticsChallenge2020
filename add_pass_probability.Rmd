---
title: "Adding pass probability"
author: "Robbie Thompson"
date: "7/15/2020"
output: pdf_document
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(tidyr)
library(dplyr)
library(readr)
library(InformationValue)
```

```{r upload date}
data2020 <- read_csv("~/Desktop/Comp Sci Projects/AnalyticsChallenge2020/Data/AnalyticsChallenge2020Data.csv")
```

```{r futzing}
odd <- is.na(data2020$UsedDesignedGap) == (data2020$IsRushing == 0)
odd <- which(odd) 
odd <- odd[seq(1,100, 4)]
numToShow = 50
head(data2020$PlayDesc[odd], numToShow)
head(data2020$UsedDesignedGap[odd], numToShow)
head(data2020$IsRushing[odd], numToShow)
head(data2020$EventType, numToShow)
```

Note to rest of team: this is awfully confusing output. I have not a clue what the "IsRushing" column means. But it sure seems like having NULL for UsedDesignedGap does a very good job of showing whether the play is a designed rush or not.

```{r}
toSee <- data2020$UsedDesignedGap == "NULL"
toSee <- which(toSee)
toSee <- toSee[seq(1,100, 4)]
numToShow = 50
head(data2020$PlayDesc[toSee], numToShow)
```

Hypothesis somewhat reinforced. Now to the task of a logistic regression.

Creating new columns:

```{r}
data2020 <- mutate(data2020, IsPass = (UsedDesignedGap == "NULL"))
data2020 <- mutate(data2020, TimeInGame = ((4 - Quarter) * 900 + TimeLeft))
data2020 <- mutate(data2020, TimeInHalf = ((Quarter %% 2) * 900 + TimeLeft))
data2020 <- mutate(data2020, ScoreDiff = (OffTeamScoreBefore - DefTeamScoreBefore))
#View(data2020)
```

We have five dependent variables (Down, ToGo, ScoreDiff, TimeInHalf, TimeInGame) and one independent variable (IsPass).

Remove the same play duplicated for each player involved so that we can speed up algorithm runtime.

```{r}
trimmedDF <- select(data2020, GameID, EventID)
uniqueGameEventCombos <- unique(trimmedDF)
trimmedDfMerged <- inner_join(uniqueGameEventCombos, data2020)
View(trimmedDfMerged)
```

This didn't actually work, get back to it later.



Create, test, train, and validation datasets.
```{r}
numDataPoints <- length(data2020$ToGo)
endTrain <- round(numDataPoints * 0.65)
endValidation <- round(numDataPoints * 0.8)

usefulData <- select(data2020, Down, ToGo, ScoreDiff, TimeInHalf, TimeInGame, IsPass)
trainSet <- usefulData[1:endTrain,]
validationSet <- usefulData[endTrain:endValidation,]
testSet <- usefulData[endValidation:numDataPoints,]
```

Train three logistic regression models.

```{r}
logRegModel1 <- glm(IsPass ~ Down + ToGo + ScoreDiff + TimeInHalf + TimeInGame, 
                    data = trainSet, family = binomial(link="logit"))
logRegModel2 <- glm(IsPass ~ Down + ToGo + ScoreDiff + TimeInGame, 
                    data = trainSet, family = binomial(link="logit"))
logRegModel3 <- glm(IsPass ~ Down + ToGo + ScoreDiff + TimeInHalf,
                    data = trainSet, family = binomial(link="logit"))

```



```{r}
# Calculate the accuracy given a model and a set to predict.
accuracy <- function(model, data) {
  pred <- plogis(predict(model, data))
  optCutOff <- 0.5
  error <- misClassError(data$IsPass, pred, threshold = 0.5)
  return(1 - error)
}
```

```{r}
print(accuracy(logRegModel1, testSet))
print(accuracy(logRegModel2, testSet))
print(accuracy(logRegModel3, testSet))

print(accuracy(logRegModel1, validationSet))
print(accuracy(logRegModel2, validationSet))
print(accuracy(logRegModel3, validationSet))
```
Our accuracy is best on our validation set when we use both time in half and time in game in our regression.


Accuracy on our test set:

```{r}
print(accuracy(logRegModel1, testSet))
```

66% accuracy really isn't great, but its OK. I guess football coaches are good at bluffing. Let's just this against the percent of overall plays which were passes:

```{r}
numPlays = numDataPoints
numPasses = sum(data2020$IsPass)
numPasses / numPlays
```
So we're doing 10% better than just always guessing pass.

merge with overall dataset:

```{r}
data2020$percentPass = plogis(predict(logRegModel1, data2020))
```




